#!/usr/bin/env python3
"""
Generate log_tags.h with list of ESP_LOG tags found in the codebase.
Run during build to enable tab completion for 'debug' command.
"""

import os
import re
import sys
from pathlib import Path

# Directories to scan (relative to project root)
SCAN_DIRS = [
    "main",
    "components",
]

# Directories to skip
SKIP_DIRS = [
    "managed_components",
    "build",
    "test_host",
]

# Pattern to match: static const char *TAG = "tagname";
TAG_PATTERN = re.compile(r'static\s+const\s+char\s*\*\s*TAG\s*=\s*"([^"]+)"')


def find_tags(root_dir: Path) -> set:
    """Find all ESP_LOG tags in C source files."""
    tags = set()

    for scan_dir in SCAN_DIRS:
        dir_path = root_dir / scan_dir
        if not dir_path.exists():
            continue

        for c_file in dir_path.rglob("*.c"):
            # Skip files in excluded directories
            skip = False
            for skip_dir in SKIP_DIRS:
                if skip_dir in str(c_file):
                    skip = True
                    break
            if skip:
                continue

            try:
                content = c_file.read_text(encoding='utf-8', errors='ignore')
                matches = TAG_PATTERN.findall(content)
                tags.update(matches)
            except Exception as e:
                print(f"Warning: Could not read {c_file}: {e}", file=sys.stderr)

    return tags


def generate_header(tags: set, output_path: Path):
    """Generate log_tags.h with the tag list."""
    sorted_tags = sorted(tags)

    content = '''/**
 * @file log_tags.h
 * @brief Auto-generated list of ESP_LOG tags for tab completion
 *
 * DO NOT EDIT - Generated by scripts/gen_log_tags.py during build
 */

#ifndef LOG_TAGS_H
#define LOG_TAGS_H

#include <stddef.h>

static const char *LOG_TAGS[] = {
'''

    for tag in sorted_tags:
        content += f'    "{tag}",\n'

    content += '''};

#define LOG_TAGS_COUNT (sizeof(LOG_TAGS) / sizeof(LOG_TAGS[0]))

#endif /* LOG_TAGS_H */
'''

    # Only write if content changed
    if output_path.exists():
        existing = output_path.read_text()
        if existing == content:
            print(f"log_tags.h unchanged ({len(sorted_tags)} tags)")
            return

    output_path.write_text(content)
    print(f"Generated log_tags.h with {len(sorted_tags)} tags: {', '.join(sorted_tags)}")


def main():
    # Determine project root
    if len(sys.argv) > 1:
        root_dir = Path(sys.argv[1])
    else:
        root_dir = Path(__file__).parent.parent

    # Output path
    output_dir = root_dir / "components" / "keyer_console" / "include"
    output_path = output_dir / "log_tags.h"

    # Ensure output directory exists
    output_dir.mkdir(parents=True, exist_ok=True)

    # Find and generate
    tags = find_tags(root_dir)

    # Add some common ESP-IDF tags that might not be in our code
    common_tags = {"wifi", "esp_netif", "esp_tls", "mqtt", "http_client"}
    tags.update(common_tags)

    generate_header(tags, output_path)


if __name__ == "__main__":
    main()
